@using BlazorApp1.Data;
@using BlazorApp1.Models;
@inject Chessrules rules;

@foreach(var piece in CapturedPieces)
{
    <Piece Model="piece" />
}
<CascadingValue Value="this">
    @ChildContent
</CascadingValue>



@code {
    public List<PieceModel> CapturedPieces { get; private set; } = new List<PieceModel>();
    [Parameter] public List<PieceModel> Pieces { get; set; }
    [Parameter] public List<SquareModel> Squares { get; set; }
    [Parameter] public EventCallback<PieceModel> OnStatusUpdated { get; set; }
    [Parameter] public EventCallback<PieceModel> OnRefresh { get; set; }
    [Parameter] public RenderFragment ChildContent { get; set; }
    public string Payload { get; set; }

    public async Task VisualizeLegalMoves(PieceModel piece)
    {
        var legalMoves = rules.GetLegalMoves(piece, Pieces, false);
        var legalSquares = Squares.Where(s => legalMoves.Contains(s.Position));
        if (legalSquares?.Any() ?? false)
        {
            foreach(var square in legalSquares)
            {
                square.IsLegalSquare = true;
            }
        }
        var illegalSquares = Squares.Where(s => !legalMoves.Contains(s.Position));
        foreach (var square in illegalSquares)
        {
            square.IsLegalSquare = false;
        }

        await OnRefresh.InvokeAsync();
    }


    public async Task UpdatePieceAsync((int x, int y) newPos)
    {

        //capture piece
        if (Pieces.FirstOrDefault(p => p.Position == newPos) is PieceModel capturedPiece)
        {
            CapturedPieces.Add(capturedPiece);
            Pieces.Remove(capturedPiece);
        }
        var piece = Pieces.FirstOrDefault(p => p.Id == Payload);
        if(piece != null)
        {
            piece.Position = newPos;
        }
        await OnStatusUpdated.InvokeAsync(piece);
    }

    public PieceModel GetCurrentPayload()
    {
        return this.Pieces.First(p => p.Id == Payload);
    }
}
